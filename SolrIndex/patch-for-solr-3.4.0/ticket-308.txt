Index: solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java
===================================================================
--- solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java	(revision 1204515)
+++ solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java	(working copy)
@@ -186,19 +186,35 @@
     int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);
     for (Token token : options.tokens) {
       String tokenText = new String(token.buffer(), 0, token.length());
+      term = new Term(field, tokenText);
+      int docFreq = 0;
+      if (reader != null) {
+    	  docFreq = reader.docFreq(term);
+      }
+      
       String[] suggestions = spellChecker.suggestSimilar(tokenText,
-              count,
-            field != null ? reader : null, //workaround LUCENE-1295
-            field,
-            options.onlyMorePopular, theAccuracy);
-      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {
-      	//These are spelled the same, continue on
-        continue;
+          count, field != null ? reader : null, // workaround LUCENE-1295
+          field, options.onlyMorePopular, theAccuracy);
+      // If considering alternatives to "correctly-spelled" terms, then add the
+      // original as a viable suggestion.
+      if (docFreq > 0) {
+        boolean foundOriginal = false;
+        String[] suggestionsWithOrig = new String[suggestions.length + 1];
+        for (int i = 0; i < suggestions.length; i++) {
+          if (suggestions[i].equals(tokenText)) {
+            foundOriginal = true;
+            break;
+          }
+          suggestionsWithOrig[i + 1] = suggestions[i];
+        }
+        if (!foundOriginal) {
+          suggestionsWithOrig[0] = tokenText;
+          suggestions = suggestionsWithOrig;
+        }
       }
 
       if (options.extendedResults == true && reader != null && field != null) {
-        term = term.createTerm(tokenText);
-        result.addFrequency(token, reader.docFreq(term));
+        result.addFrequency(token, docFreq);
         int countLimit = Math.min(options.count, suggestions.length);
         if(countLimit>0)
         {
Index: solr/core/src/java/org/apache/solr/spelling/PossibilityIterator.java
===================================================================
--- solr/core/src/java/org/apache/solr/spelling/PossibilityIterator.java	(revision 1204515)
+++ solr/core/src/java/org/apache/solr/spelling/PossibilityIterator.java	(working copy)
@@ -94,6 +94,9 @@
 			if(rankedPossibilities.size() >= maximumRequiredSuggestions && rsp.getRank() >= rankedPossibilities.peek().getRank()) {
 				continue;
 			}
+			if (!isSuggestionForReal(rsp)) {
+			     continue;
+			}
 			rankedPossibilities.offer(rsp);
 			if(rankedPossibilities.size() > maximumRequiredSuggestions) {
 				rankedPossibilities.poll();
@@ -106,7 +109,16 @@
 		}
 		rankedPossibilityIterator = Arrays.asList(rpArr).iterator();		
 	}
-
+		
+	  private boolean isSuggestionForReal(RankedSpellPossibility rsp) {
+	    for (SpellCheckCorrection corr : rsp.getCorrections()) {
+	      if (!corr.getOriginalAsString().equals(corr.getCorrection())) {
+	        return true;
+	      }
+	    }
+	    return false;
+	  }
+	 
 	private boolean internalHasNext() {
 		return !done;
 	}
Index: solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator.java
===================================================================
--- solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator.java	(revision 1204515)
+++ solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator.java	(working copy)
@@ -23,6 +23,8 @@
 import org.apache.lucene.analysis.Token;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.SpellingParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.handler.component.QueryComponent;
 import org.apache.solr.handler.component.ResponseBuilder;
@@ -37,8 +39,8 @@
 
   public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,
                                            int maxCollations, int maxTries, int maxEvaluations) {
+    Integer queryHits = ultimateResponse.getResults().docList.matches();
     List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();
-
     QueryComponent queryComponent = null;
     if (ultimateResponse.components != null) {
       for (SearchComponent sc : ultimateResponse.components) {
@@ -97,7 +99,7 @@
           checkResponse.req.close();  
         }
       }
-      if (hits > 0 || !verifyCandidateWithQuery) {
+      if ((hits > 0 && hits > queryHits) || !verifyCandidateWithQuery) {
         collNo++;
         SpellCheckCollation collation = new SpellCheckCollation();
         collation.setCollationQuery(collationQueryStr);
Index: solr/core/src/java/org/apache/solr/spelling/SpellCheckCorrection.java
===================================================================
--- solr/core/src/java/org/apache/solr/spelling/SpellCheckCorrection.java	(revision 1204515)
+++ solr/core/src/java/org/apache/solr/spelling/SpellCheckCorrection.java	(working copy)
@@ -19,16 +19,25 @@
 import org.apache.lucene.analysis.Token;
 
 public class SpellCheckCorrection {
+
 	private Token original;
+	private String originalAsString = null;
 	private String correction;
 	private int numberOfOccurences;
 
 	public Token getOriginal() {
 		return original;
 	}
-
+	  
+	  public String getOriginalAsString() {
+	    if (originalAsString == null && original != null) {
+	      originalAsString = original.toString();
+	    }
+	    return originalAsString;
+	  }
 	public void setOriginal(Token original) {
 		this.original = original;
+		 this.originalAsString = null;
 	}
 
 	public String getCorrection() {
Index: solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest.java	(revision 1204515)
+++ solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.search.SolrIndexReader;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -45,6 +46,11 @@
 		assertNull(h.validateUpdate(adoc("id", "3", "lowerfilt", "faith of homer")));
 		assertNull(h.validateUpdate(adoc("id", "4", "lowerfilt", "fat of homer")));
 		assertNull(h.validateUpdate(adoc("id", "5", "lowerfilt1", "peace")));
+		assertNull(h.validateUpdate(adoc("id", "6", "lowerfilt", "fait of hops")));	
+		assertNull(h.validateUpdate(adoc("id", "7", "lowerfilt", "hops of homer")));
+		assertNull(h.validateUpdate(adoc("id", "8", "lowerfilt", "hops of love")));	
+		assertNull(h.validateUpdate(adoc("id", "9", "lowerfilt", "faith of homer and others")));
+		assertNull(h.validateUpdate(adoc("id", "10", "lowerfilt", "faith of homer and ape")));
 		assertNull(h.validateUpdate(commit()));
 	}
 	
@@ -236,4 +242,91 @@
 			assertTrue(correctionForLoane.equals("love") || correctionForLoane.equals("loaves"));
 		}
 	}
+	@Test
+	public void testExtendedCollateWithCorrectWords() throws Exception {
+		SolrCore core = h.getCore();
+		SearchComponent speller = core.getSearchComponent("spellcheck");
+		assertTrue("speller is null and it shouldn't be", speller != null);
+
+		ModifiableSolrParams params = new ModifiableSolrParams();
+		params.add(CommonParams.QT, "spellCheckCompRH");
+		params.add(CommonParams.Q, "lowerfilt:(+faith +hooe)");
+		params.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, "true");
+		params.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, "true");
+		params.add(SpellCheckComponent.COMPONENT_NAME, "true");
+		params.add(SpellCheckComponent.SPELLCHECK_BUILD, "true");
+		params.add(SpellCheckComponent.SPELLCHECK_COUNT, "10");
+		params.add(SpellCheckComponent.SPELLCHECK_COLLATE, "true");
+		params.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, "10");
+		params.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, "4");
+		// Testing backwards-compatible behavior.
+		// Returns 1 collation as a single string.
+		// All words are "correct" per the dictionary, but this collation would
+		// return no results if tried.
+		SolrRequestHandler handler = core.getRequestHandler("spellCheckCompRH");
+		SolrQueryResponse rsp = new SolrQueryResponse();
+		rsp.add("responseHeader", new SimpleOrderedMap());
+		SolrQueryRequest req = new LocalSolrQueryRequest(core, params);
+		handler.handleRequest(req, rsp);
+		req.close();
+		NamedList values = rsp.getValues();
+		int queryHits = (Integer) rsp.getToLog().get("hits");
+		NamedList spellCheck = (NamedList) values.get("spellcheck");
+		NamedList suggestions = (NamedList) spellCheck.get("suggestions");
+		List<NamedList> expandedCollationList = suggestions.getAll("collation");
+		Set<String> usedcollations = new HashSet<String>();
+		assertEquals(3,expandedCollationList.size());
+		for (NamedList expandedCollation : expandedCollationList) {
+			String multipleCollation = (String) expandedCollation.get("collationQuery");
+			assertTrue(multipleCollation.equals("lowerfilt:(+faith +hope)") ||
+					multipleCollation.equals("lowerfilt:(+faith +homer)") || multipleCollation.equals("lowerfilt:(+faith +love)"));
+			assertTrue(!usedcollations.contains(multipleCollation));
+			usedcollations.add(multipleCollation);
+
+			int hits = (Integer) expandedCollation.get("hits");
+			assertTrue(hits > queryHits);
+			NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get("misspellingsAndCorrections");
+			assertTrue(misspellingsAndCorrections.size() == 2);
+		}
+		
+		//try with more popular results 
+		params.add(SpellCheckComponent.SPELLCHECK_ONLY_MORE_POPULAR, "true");
+		// Testing backwards-compatible behavior.
+		// Returns 1 collation as a single string.
+		// All words are "correct" per the dictionary, but this collation would
+		// return no results if tried.
+		handler = core.getRequestHandler("spellCheckCompRH");
+		params.remove(CommonParams.Q);
+		params.add(CommonParams.Q, "lowerfilt:(+faith +hope)");
+		rsp = new SolrQueryResponse();
+		rsp.add("responseHeader", new SimpleOrderedMap());
+		req = new LocalSolrQueryRequest(core, params);
+		handler.handleRequest(req, rsp);
+		req.close();
+		values = rsp.getValues();
+		queryHits = (Integer) rsp.getToLog().get("hits");
+		spellCheck = (NamedList) values.get("spellcheck");
+		suggestions = (NamedList) spellCheck.get("suggestions");
+		expandedCollationList = suggestions.getAll("collation");
+		usedcollations = new HashSet<String>();
+		assertEquals(1,expandedCollationList.size());
+		for (NamedList expandedCollation : expandedCollationList) {
+			String multipleCollation = (String) expandedCollation.get("collationQuery");
+			assertTrue(multipleCollation.equals("lowerfilt:(+faith +homer)"));
+			assertTrue(!usedcollations.contains(multipleCollation));
+			usedcollations.add(multipleCollation);
+
+			int hits = (Integer) expandedCollation.get("hits");
+			assertTrue(hits == 3);
+			assertTrue(hits > queryHits);
+			NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get("misspellingsAndCorrections");
+			assertTrue(misspellingsAndCorrections.size() == 2);
+
+			String correctionForFauth = (String) misspellingsAndCorrections.get("faith");
+			String correctionForHome = (String) misspellingsAndCorrections.get("hope");
+			assertTrue(correctionForFauth.equals("faith"));
+			assertTrue(correctionForHome.equals("homer"));
+		}
+	}
+
 }
